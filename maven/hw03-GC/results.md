Для рассматриваемого мной приложения лучший результат по времени работы программы показал Parallel_GC при всех вариантах размера, выделенного для Heap памяти. 
При этом самый лучший вариант по критерию минимального времени работы программы показал вариант с заданным размером Heap=512, когда не потребовалось ни одной полной сборки (major). 
При этом в 2.75 раза увеличилась пропускная способность, то есть процент затрачиваемого времени на сборку мусора составил относительно общего времени работы программы 28% (против 77% в при Heap=128). 
Нужно также отметить, что задача в рассматриваемом приложении легко поддавалась распараллеливанию и не использовались объекты большого размера, что повышает эффективность работы Parallel в данном случае. 
Кроме того, если имеет значение постоянство времени задержки, необходимой для сборки мусора, или минимальное количество сборок, то лучше выбрать G1. 


;Young_сборок в мин;Old_сборок в мин;Время работы программы, с ;Young_ время на сборку (среднее), мс;Old_ время на сборку (среднее), мс;время сборки Young, мс;время сборки Old, мс;% времени на сборку относительно общего времени работы программы
G1_128;1855;314;135;39;39;74649;12948;64.88666667
ParallelGC_128;1987;400;80;35;8.7;54936;7038;77.4675
UseConcMarkSweepGC_128;798;798;107;20;73;31599;57828;83.57663551
G1_256;456;81;127;71;37;70945;6350;60.86220472
ParallelGC_256;1191;149;79;36;20.1;57868;3921;78.21392405
UseConcMarkSweepGC_256;576;115;82;54;128;43730;21009;78.95
G1_512;245;3;119;124;8;72924;12559;63.32074074
G1_512_MaxGCPauseMillis=100000;202;447;138;194;44;88332;3341;66.42971014
G1_512_MaxGCPauseMillis=10;439;0;131;57;0;57202;0;43.66564885
ParallelGC_512;1129;0;24;25;0;6783;0;28.2625
UseConcMarkSweepGC_512;490;71;44;62;62;22621;3341;59.00454545
